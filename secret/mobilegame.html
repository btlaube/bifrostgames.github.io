<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Orb Runner — Avoid & Blast (Mobile First)</title>
<style>
  :root{
    --bg1: #071021;
    --bg2: #0b1b2b;
    --panel: rgba(255,255,255,0.06);
    --accent: #FFD66B;
    --muted: #9fb0c8;
    --danger: #ff6b6b;
  }
  html,body{
    height:100%;
    margin:0;
    background: radial-gradient(1000px 600px at 10% 10%, rgba(255,255,255,0.02), transparent 20%), linear-gradient(180deg,var(--bg1),var(--bg2));
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:#e6eef8;
    -webkit-user-select:none;
    user-select:none;
    -webkit-tap-highlight-color:transparent;
    -webkit-font-smoothing:antialiased;
  }

  .game-wrap{
    position:relative;
    width:100%;
    height:100vh;
    overflow:hidden;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  canvas#game {
    width:100%;
    height:100%;
    display:block;
    touch-action:none;
    image-rendering: optimizeSpeed;
    background: transparent;
  }

  /* HUD */
  .hud{
    position:absolute;
    top:10px;
    left:10px;
    display:flex;
    gap:8px;
    align-items:center;
    z-index:40;
  }
  .chip{
    background:var(--panel);
    padding:8px 12px;
    border-radius:12px;
    font-size:14px;
    display:flex;
    gap:8px;
    align-items:center;
    box-shadow: 0 8px 26px rgba(2,6,23,0.5);
    backdrop-filter: blur(6px);
  }
  .chip strong{ color:var(--accent); font-weight:700; margin-left:4px;}

  .controls-top{
    position:absolute;
    top:10px;
    right:10px;
    display:flex;
    gap:8px;
    z-index:40;
  }
  .btn {
    background:var(--panel);
    border-radius:10px;
    padding:8px 10px;
    display:inline-flex;
    gap:8px;
    align-items:center;
    cursor:pointer;
    font-size:13px;
    user-select:none;
  }
  .btn:active { transform: translateY(1px); }

  /* Mobile controls */
  .mobile-controls{
    position:absolute;
    bottom:12px;
    left:12px;
    right:12px;
    pointer-events:none;
    z-index:30;
    display:flex;
    justify-content:space-between;
    align-items:flex-end;
  }
  .joystick {
    width:140px;
    height:140px;
    pointer-events:auto;
    touch-action:none;
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  .stick-base {
    width:100%;
    height:100%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.03), transparent 40%);
    border-radius:50%;
    border:2px solid rgba(255,255,255,0.03);
    display:flex;
    align-items:center;
    justify-content:center;
    box-shadow: 0 10px 30px rgba(0,0,0,0.6) inset;
  }
  .stick-knob {
    width:52px;
    height:52px;
    border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(255,255,255,0.02));
    border: 2px solid rgba(255,255,255,0.06);
    transform: translate(0,0);
    transition: transform 0.03s linear;
    pointer-events:none;
    box-shadow: 0 8px 20px rgba(0,0,0,0.6);
  }

  .action-button {
    pointer-events:auto;
    width:96px;
    height:96px;
    border-radius:50%;
    background: linear-gradient(180deg, rgba(255,210,120,0.06), rgba(0,0,0,0.08));
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    font-size:16px;
    color:var(--accent);
    border:3px solid rgba(255,255,255,0.04);
    box-shadow: 0 12px 40px rgba(0,0,0,0.5);
  }

  /* overlay panel */
  .overlay {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:50;
    pointer-events:none;
  }
  .panel {
    pointer-events:auto;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.08));
    border-radius:14px;
    padding:18px;
    text-align:center;
    min-width:240px;
    color:#f2f6ff;
    box-shadow: 0 12px 40px rgba(2,6,23,0.6);
    backdrop-filter: blur(6px);
  }
  .panel h2{ margin:0 0 8px; font-size:20px; color:var(--accent); }
  .panel p{ margin:0 0 12px; color:var(--muted); font-size:14px; }

  .hint {
    position:absolute;
    bottom:10px;
    left:50%;
    transform:translateX(-50%);
    font-size:12px;
    color:var(--muted);
    z-index:40;
    text-shadow: 0 2px 6px rgba(0,0,0,0.6);
  }

  @media (max-width:520px){
    .joystick { width:120px; height:120px; }
    .stick-knob { width:46px; height:46px; }
    .action-button { width:84px; height:84px; font-size:15px; }
    .chip { font-size:13px; padding:6px 10px; border-radius:10px;}
  }

  .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
</style>
</head>
<body>
<div class="game-wrap" id="gameWrap">
  <canvas id="game" width="900" height="1600" aria-label="Avoid obstacles game canvas"></canvas>

  <div class="hud" role="region" aria-live="polite">
    <div class="chip">Score: <strong id="score">0</strong></div>
    <div class="chip">HP: <strong id="hp">5</strong></div>
  </div>

  <div class="controls-top">
    <div class="btn" id="pauseBtn" role="button" tabindex="0">Pause</div>
  </div>

  <div class="mobile-controls" id="mobileControls" aria-hidden="false">
    <div class="joystick" id="joystick" aria-label="Movement joystick">
      <div class="stick-base">
        <div class="stick-knob" id="stickKnob" aria-hidden="true"></div>
      </div>
    </div>
    <div style="display:flex; gap:12px; align-items:flex-end;">
      <div class="action-button" id="actionBtn" role="button" tabindex="0" aria-pressed="false">BLAST</div>
    </div>
  </div>

  <div class="overlay" id="overlay" aria-hidden="true">
    <div class="panel" id="panel" style="display:none;">
      <h2 id="panelTitle">Paused</h2>
      <p id="panelBody">Tap resume to continue.</p>
      <div style="display:flex;gap:8px;justify-content:center;">
        <div class="btn" id="resumeBtn">Resume</div>
        <div class="btn" id="restartBtn">Restart</div>
      </div>
    </div>
  </div>

  <div class="hint">Mobile: joystick + blast · Desktop: WASD/Arrows + Space</div>
</div>

<div class="sr-only" id="srStatus" aria-live="polite"></div>

<script>
(() => {
  // CONFIG
  const CONFIG = {
    worldWidth: 900,
    worldHeight: 1600,
    playerR: 20,
    playerSpeed: 340,
    enemyBaseSpeed: 60,
    enemySpawnBase: 1400,
    coinSpawnBase: 1100,
    blastCooldown: 2000,
    blastRadius: 120,
    maxHP: 5,
    dprLimit: 2.5,
  };

  // canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });

  // UI elements
  const scoreEl = document.getElementById('score');
  const hpEl = document.getElementById('hp');
  const overlay = document.getElementById('overlay');
  const panel = document.getElementById('panel');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');
  const actionBtn = document.getElementById('actionBtn');
  const stickKnob = document.getElementById('stickKnob');

  // state
  const state = {
    running: false,
    paused: false,
    lastTime: 0,
    score: 0,
    hp: CONFIG.maxHP,
    player: { x: CONFIG.worldWidth/2, y: CONFIG.worldHeight*0.7, vx:0, vy:0 },
    enemies: [],
    particles: [],
    spawnTimers: { enemy:0, coin:0 },
    enemyWave: 0,
    lastBlast: -999999,
    startTime: 0,
  };

  // joystick
  const joystick = {
    active: false,
    startX: 0, startY: 0,
    maxRadius: 52,
    outputX: 0, // -1..1 (left..right)
    outputY: 0, // 1 = up, -1 = down (we'll apply minus when moving)
  };

  // keyboard state
  const keys = {};

  // Responsive canvas sizing
  function resizeCanvas(){
    const wrap = document.getElementById('gameWrap');
    const rect = wrap.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, CONFIG.dprLimit);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resizeCanvas);
  window.addEventListener('orientationchange', resizeCanvas);

  // utilities
  const rand = (a,b) => Math.random()*(b-a)+a;
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const dist = (x1,y1,x2,y2) => Math.hypot(x1-x2, y1-y2);

  // spawn enemy
  function spawnEnemy(){
    // spawn at random edge
    const edge = Math.floor(Math.random()*4);
    let x,y;
    if (edge===0){ x = rand(-40, CONFIG.worldWidth+40); y = -60; }
    else if (edge===1){ x = rand(-40, CONFIG.worldWidth+40); y = CONFIG.worldHeight + 60; }
    else if (edge===2){ x = -60; y = rand(-40, CONFIG.worldHeight+40); }
    else { x = CONFIG.worldWidth + 60; y = rand(-40, CONFIG.worldHeight+40); }
    const speed = CONFIG.enemyBaseSpeed + state.enemyWave*6 + rand(-8,16);
    const size = rand(12,26);
    const spin = rand(-0.12,0.12);
    state.enemies.push({ x,y, r: size, speed, spin, ang: rand(0,Math.PI*2) });
  }

  // spawn some ambient particles for background
  const bgParticles = [];
  function createBgParticles(){
    const n = 40;
    for (let i=0;i<n;i++){
      bgParticles.push({
        x: rand(0, CONFIG.worldWidth),
        y: rand(0, CONFIG.worldHeight),
        r: rand(1.2,4.6),
        vx: rand(-6,6),
        vy: rand(-6,6),
        alpha: rand(0.06,0.22),
      });
    }
  }
  createBgParticles();

  // reset game
  function resetGame(){
    state.score = 0;
    state.hp = CONFIG.maxHP;
    state.player.x = CONFIG.worldWidth/2;
    state.player.y = CONFIG.worldHeight*0.7;
    state.enemies = [];
    state.particles = [];
    state.spawnTimers.enemy = 0;
    state.enemyWave = 0;
    state.lastBlast = -999999;
    state.running = true;
    state.paused = false;
    state.startTime = performance.now();
    updateUI();
    // pre-spawn some enemies
    for (let i=0;i<3;i++) spawnEnemy();
  }

  function updateUI(){
    scoreEl.textContent = Math.floor(state.score);
    hpEl.textContent = state.hp;
    document.getElementById('srStatus').textContent = `Score ${Math.floor(state.score)} HP ${state.hp}`;
  }

  // blast action
  function doBlast(){
    const now = performance.now();
    if (now - state.lastBlast < CONFIG.blastCooldown) return;
    state.lastBlast = now;
    // eliminate enemies within radius
    const px = state.player.x, py = state.player.y;
    for (let i = state.enemies.length-1; i>=0; i--){
      const e = state.enemies[i];
      const d = dist(px,py,e.x,e.y);
      if (d <= CONFIG.blastRadius + e.r){
        spawnParticles(e.x, e.y, Math.floor(e.r/2)+6);
        state.enemies.splice(i,1);
        state.score += 8;
      }
    }
    spawnParticles(px,py,18);
  }

  // particle helper
  function spawnParticles(x,y,n=8){
    for (let i=0;i<n;i++){
      const a = rand(0,Math.PI*2);
      const s = rand(40,240);
      state.particles.push({
        x,y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        life: rand(400,1100),
        born: performance.now(),
        size: rand(1.5,4.6),
        color: `hsla(${Math.floor(rand(180,260))}, 90%, ${rand(60,80)}%, 1)`
      });
    }
  }

  // game over
  function gameOver(){
    state.running = false;
    showPanel('Game Over', `Score: ${Math.floor(state.score)}`);
  }

  // panel controls
  function showPanel(title, body, withButtons=true){
    document.getElementById('panelTitle').textContent = title;
    document.getElementById('panelBody').textContent = body || '';
    panel.style.display = 'block';
    overlay.style.pointerEvents = 'auto';
    overlay.setAttribute('aria-hidden','false');
    if (!withButtons){
      resumeBtn.style.display = 'none';
      restartBtn.style.display = '';
    } else {
      resumeBtn.style.display = '';
      restartBtn.style.display = '';
    }
  }
  function hidePanel(){
    panel.style.display = 'none';
    overlay.style.pointerEvents = 'none';
    overlay.setAttribute('aria-hidden','true');
  }

  // main loop
  function update(ts){
    if (!state.running || state.paused){
      state.lastTime = ts;
      requestAnimationFrame(update);
      return;
    }
    if (!state.lastTime) state.lastTime = ts;
    let dt = (ts - state.lastTime)/1000;
    dt = Math.min(dt, 0.05);
    state.lastTime = ts;

    // input: horizontal from joystick or keyboard
    const jx = joystick.outputX || 0;
    const jy = joystick.outputY || 0; // 1 = up, -1 = down (we apply below)
    const kx = (keys.ArrowRight || keys.d) ? 1 : (keys.ArrowLeft || keys.a) ? -1 : 0;
    const ky = (keys.ArrowUp || keys.w) ? 1 : (keys.ArrowDown || keys.s) ? -1 : 0;

    const inputX = Math.abs(jx) > 0.01 ? jx : kx;
    const inputY = Math.abs(jy) > 0.01 ? jy : ky; // positive means up

    // move player: horizontal directly, vertical subtract because canvas y grows downward
    state.player.x += inputX * CONFIG.playerSpeed * dt;
    state.player.y -= inputY * CONFIG.playerSpeed * dt; // subtract so positive inputY moves up

    // clamp
    state.player.x = clamp(state.player.x, 12, CONFIG.worldWidth - 12);
    state.player.y = clamp(state.player.y, 12, CONFIG.worldHeight - 12);

    // spawn enemies over time, faster as waves increase
    state.spawnTimers.enemy += dt*1000;
    const spawnInterval = Math.max(600, CONFIG.enemySpawnBase - state.enemyWave*12);
    if (state.spawnTimers.enemy >= spawnInterval){
      state.spawnTimers.enemy = 0;
      spawnEnemy();
      state.enemyWave++;
    }

    // enemies movement: move toward player
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      e.ang += e.spin * dt * 60;
      const dx = state.player.x - e.x;
      const dy = state.player.y - e.y;
      const d = Math.hypot(dx, dy) || 1;
      e.x += (dx/d) * e.speed * dt;
      e.y += (dy/d) * e.speed * dt;
      // collision with player
      if (dist(e.x,e.y, state.player.x, state.player.y) < e.r + CONFIG.playerR){
        spawnParticles(e.x, e.y, 10);
        state.enemies.splice(i,1);
        state.hp -= 1;
        if (state.hp <= 0) { updateUI(); gameOver(); return; }
      }
    }

    // update particles
    for (let i=state.particles.length-1;i>=0;i--){
      const p = state.particles[i];
      const life = performance.now() - p.born;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;
      if (life > p.life) state.particles.splice(i,1);
    }

    // background particles gentle drift
    for (const bp of bgParticles){
      bp.x += bp.vx * dt * 0.15;
      bp.y += bp.vy * dt * 0.15;
      if (bp.x < -10) bp.x = CONFIG.worldWidth + 10;
      if (bp.x > CONFIG.worldWidth + 10) bp.x = -10;
      if (bp.y < -10) bp.y = CONFIG.worldHeight + 10;
      if (bp.y > CONFIG.worldHeight + 10) bp.y = -10;
    }

    // auto-score by survival time and enemies dodged
    state.score += dt * 2.6;
    updateUI();
    render();
    requestAnimationFrame(update);
  }

  // render everything
  function render(){
    const cssW = canvas.width / (window.devicePixelRatio || 1);
    const cssH = canvas.height / (window.devicePixelRatio || 1);
    ctx.clearRect(0,0, cssW, cssH);

    // scale world to CSS area: we will draw using virtual world coordinates
    // but canvas CSS is stretched to the viewport; we map world to canvas rect
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / CONFIG.worldWidth;
    const scaleY = rect.height / CONFIG.worldHeight;
    // use uniform scale to preserve aspect
    const scale = Math.min(scaleX, scaleY);
    const offsetX = (rect.width - CONFIG.worldWidth * scale) / 2;
    const offsetY = (rect.height - CONFIG.worldHeight * scale) / 2;

    // helper to transform world coords to canvas coords
    function wx(x){ return x * scale + offsetX; }
    function wy(y){ return y * scale + offsetY; }

    // background gradient
    const g = ctx.createLinearGradient(0,0,0,rect.height);
    g.addColorStop(0, '#071021');
    g.addColorStop(1, '#061428');
    ctx.fillStyle = g;
    ctx.fillRect(0,0, rect.width, rect.height);

    // subtle background particles glow
    for (const bp of bgParticles){
      ctx.beginPath();
      ctx.fillStyle = `rgba(140,190,255,${bp.alpha})`;
      ctx.arc(wx(bp.x), wy(bp.y), bp.r * scale * 0.9, 0, Math.PI*2);
      ctx.fill();
    }

    // decorative rotating rings subtle
    const t = performance.now()*0.00012;
    ctx.save();
    ctx.globalAlpha = 0.06;
    for (let i=0;i<3;i++){
      ctx.beginPath();
      ctx.strokeStyle = `hsl(${200 + i*30}, 60%, 60%)`;
      ctx.lineWidth = 120 * (0.9 - i*0.18) * scale;
      ctx.arc(rect.width/2, rect.height*0.33, (rect.width*0.4) + Math.sin(t*1.6 + i)*40, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.restore();

    // draw enemies (as rotating shards/triangles)
    for (const e of state.enemies){
      const cx = wx(e.x), cy = wy(e.y);
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(e.ang);
      // shadow
      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,0,0,0.22)';
      ctx.ellipse(6*scale, 10*scale, e.r*1.2*scale, e.r*0.6*scale, 0, 0, Math.PI*2);
      ctx.fill();
      // shards
      for (let s=0; s<3; s++){
        ctx.beginPath();
        ctx.moveTo(0, -e.r*scale);
        ctx.lineTo(e.r*scale*0.6, e.r*scale*0.8);
        ctx.lineTo(-e.r*scale*0.6, e.r*scale*0.8);
        ctx.closePath();
        const hue = 10 + (s*20);
        ctx.fillStyle = `hsl(${hue}, 85%, ${35 - s*4}%)`;
        ctx.fill();
      }
      ctx.restore();
    }

    // draw player as glowing pulsing orb with core and aura
    const p = state.player;
    const px = wx(p.x), py = wy(p.y);
    const pulse = 1 + Math.sin(performance.now()*0.008) * 0.07;
    const auraR = CONFIG.playerR * 2.8 * pulse * scale;
    // aura
    const rg = ctx.createRadialGradient(px, py, 0, px, py, auraR);
    rg.addColorStop(0, 'rgba(140,220,255,0.25)');
    rg.addColorStop(0.6, 'rgba(100,170,255,0.09)');
    rg.addColorStop(1, 'rgba(20,40,70,0)');
    ctx.fillStyle = rg;
    ctx.beginPath();
    ctx.arc(px, py, auraR, 0, Math.PI*2);
    ctx.fill();

    // core orb
    const orbR = CONFIG.playerR * scale;
    const orbG = ctx.createLinearGradient(px-10*scale, py-10*scale, px+10*scale, py+10*scale);
    orbG.addColorStop(0, '#BFF7FF');
    orbG.addColorStop(1, '#58A6FF');
    ctx.fillStyle = orbG;
    ctx.beginPath();
    ctx.arc(px, py, orbR, 0, Math.PI*2);
    ctx.fill();

    // inner core
    ctx.beginPath();
    ctx.fillStyle = 'white';
    ctx.globalAlpha = 0.9;
    ctx.arc(px - orbR*0.15, py - orbR*0.15, orbR*0.38, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // blast ready indicator
    if (performance.now() - state.lastBlast > CONFIG.blastCooldown){
      ctx.beginPath();
      ctx.lineWidth = 3 * scale;
      ctx.strokeStyle = 'rgba(255,220,120,0.12)';
      ctx.arc(px, py, CONFIG.blastRadius * scale * 0.96, 0, Math.PI*2);
      ctx.stroke();
    } else {
      // show cooldown ring fraction around player
      const frac = (performance.now() - state.lastBlast) / CONFIG.blastCooldown;
      ctx.beginPath();
      ctx.lineWidth = 5 * scale;
      ctx.strokeStyle = 'rgba(255,220,120,0.14)';
      ctx.arc(px, py, CONFIG.blastRadius * scale * 0.9, -Math.PI/2, -Math.PI/2 + frac*Math.PI*2);
      ctx.stroke();
    }

    // draw particles
    for (const part of state.particles){
      const lifeFrac = clamp((performance.now() - part.born) / part.life, 0, 1);
      ctx.globalAlpha = 1 - lifeFrac;
      ctx.beginPath();
      ctx.fillStyle = part.color || 'rgba(255,255,255,0.9)';
      ctx.arc(wx(part.x), wy(part.y), part.size*scale*0.6, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // optional HUD on canvas (small blast icon)
    ctx.save();
    ctx.globalAlpha = 0.9;
    const hudX = rect.width - 84;
    const hudY = rect.height - 84;
    ctx.beginPath();
    ctx.fillStyle = 'rgba(0,0,0,0.28)';
    ctx.arc(hudX, hudY, 36, 0, Math.PI*2);
    ctx.fill();
    // cooldown arc
    const cd = clamp((performance.now() - state.lastBlast)/CONFIG.blastCooldown, 0, 1);
    ctx.beginPath();
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(255,210,100,0.95)';
    ctx.arc(hudX, hudY, 30, -Math.PI/2, -Math.PI/2 + cd*Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  // input handling
  // pointer for joystick
  const joystickWrap = document.getElementById('joystick');
  let stickPointerId = null;
  joystickWrap.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    joystick.active = true;
    joystick.startX = e.clientX;
    joystick.startY = e.clientY;
    stickPointerId = e.pointerId;
    joystick.outputX = 0;
    joystick.outputY = 0;
    joystickWrap.setPointerCapture(stickPointerId);
  });
  joystickWrap.addEventListener('pointermove', (e) => {
    if (!joystick.active || e.pointerId !== stickPointerId) return;
    e.preventDefault();
    const nx = e.clientX - joystick.startX; // right positive
    const ny = joystick.startY - e.clientY; // up positive (startY - currentY)
    const max = joystick.maxRadius;
    const fx = clamp(nx / max, -1, 1);
    const fy = clamp(ny / max, -1, 1); // fy: 1 = up, -1 = down
    joystick.outputX = fx;
    joystick.outputY = fy;
    // move knob visually (limit to radius)
    const knobX = fx * max;
    const knobY = -fy * max; // invert for CSS because positive fy is up but translate Y positive moves down
    stickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
  });
  joystickWrap.addEventListener('pointerup', (e) => {
    if (e.pointerId !== stickPointerId) return;
    joystick.active = false;
    stickPointerId = null;
    joystick.outputX = 0;
    joystick.outputY = 0;
    stickKnob.style.transform = `translate(0px, 0px)`;
    try { joystickWrap.releasePointerCapture(e.pointerId); } catch(_) {}
  });
  joystickWrap.addEventListener('pointercancel', (e) => {
    joystick.active = false;
    stickPointerId = null;
    joystick.outputX = 0;
    joystick.outputY = 0;
    stickKnob.style.transform = `translate(0px, 0px)`;
  });

  // action button
  let actionPointerId = null;
  actionBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    if (actionPointerId !== null) return;
    actionPointerId = e.pointerId;
    actionBtn.setAttribute('aria-pressed','true');
    doBlast();
  });
  actionBtn.addEventListener('pointerup', (e) => {
    if (e.pointerId !== actionPointerId) return;
    actionPointerId = null;
    actionBtn.setAttribute('aria-pressed','false');
  });
  actionBtn.addEventListener('pointercancel', (e) => {
    actionPointerId = null;
    actionBtn.setAttribute('aria-pressed','false');
  });

  // keyboard
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    // quick controls
    if (e.key === 'p') togglePause();
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space' || e.key === ' ') doBlast();
  });

  // pause / resume / restart
  pauseBtn.addEventListener('click', () => togglePause());
  resumeBtn.addEventListener('click', () => { togglePause(false); hidePanel(); });
  restartBtn.addEventListener('click', () => { hidePanel(); resetGame(); startLoop(); });

  function togglePause(force){
    if (typeof force === 'boolean') state.paused = force;
    else state.paused = !state.paused;
    if (state.paused){
      showPanel('Paused', 'Tap resume to continue.');
      pauseBtn.textContent = 'Resume';
    } else {
      hidePanel();
      pauseBtn.textContent = 'Pause';
    }
  }

  // start loop
  function startLoop(){
    resizeCanvas();
    if (!state.running) resetGame();
    state.lastTime = 0;
    requestAnimationFrame(update);
    hidePanel();
  }

  // initial overlay start
  function showStartScreen(){
    showPanel('Orb Runner', 'Use joystick to dodge enemies. Blast destroys nearby enemies. Tap to start!', true);
    // start on panel click/tap
    panel.onclick = () => {
      panel.onclick = null;
      hidePanel();
      startLoop();
    };
  }

  // initial spawn
  for (let i=0;i<3;i++) spawnEnemy();
  state.running = false;
  showStartScreen();

  // expose state for debugging
  window._gameState = state;
  window._CONFIG = CONFIG;

  // prevent double-tap zoom on mobile
  let lastTouch = 0;
  document.addEventListener('touchend', (e) => {
    const t = performance.now();
    if (t - lastTouch < 300) e.preventDefault();
    lastTouch = t;
  }, { passive: false });

})();
</script>
</body>
</html>
