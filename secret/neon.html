<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Drift ‚Äî HTML5 Canvas Game</title>
  <style>
    :root{
      --bg:#07070b;
      --panel: rgba(255,255,255,0.03);
      --neon1: #7cf6ff;
      --neon2: #7d7bff;
      --accent: #ff7dd1;
      --muted: rgba(255,255,255,0.6);
      --glass: rgba(255,255,255,0.04);
      --shadow: 0 6px 30px rgba(2,6,23,0.7);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(1200px 800px at 10% 10%, rgba(125,123,255,0.06), transparent 8%),
        radial-gradient(1000px 700px at 90% 90%, rgba(124,246,255,0.04), transparent 8%),
        var(--bg);
      color: #e8eefc;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .wrap{
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 20px;
      height:100vh;
      padding:20px;
      box-sizing:border-box;
    }

    @media (max-width:900px){
      .wrap{ grid-template-columns: 1fr; grid-auto-rows: auto 320px; }
    }

    /* Game Canvas Container */
    .game-area{
      background: linear-gradient(180deg, rgba(255,255,255,0.01), transparent 30%);
      border-radius:12px;
      box-shadow: var(--shadow);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    canvas{
      flex:1 1 auto;
      width:100%;
      border-radius:8px;
      background:
        repeating-linear-gradient(45deg, rgba(255,255,255,0.01) 0 2px, transparent 2px 22px),
        linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00) 60%);
      display:block;
    }

    /* Sidebar HUD */
    .hud{
      background: linear-gradient(135deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:12px;
      box-shadow: var(--shadow);
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .score-container {
        display:flex;
        gap:10px;
        align-items:center;
        justify-content:space-between;
    }

    h1{
      margin:0;
      font-size:18px;
      letter-spacing:0.6px;
      color:var(--neon1);
      display:flex;
      align-items:center;
      gap:8px;
    }

    .controls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }

    button{
      background: linear-gradient(to bottom right, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.04);
      padding:8px 12px;
      border-radius:10px;
      cursor:pointer;
      font-weight:600;
      box-shadow: 0 6px 18px rgba(2,6,23,0.5);
    }

    .big{
      font-size:14px;
      padding:12px 16px;
      background: linear-gradient(90deg,var(--neon1),var(--neon2));
      color:#071025;
      border: none;
      box-shadow: 0 8px 28px rgba(125,123,255,0.15);
    }

    .stat{
      background:var(--glass);
      border-radius:8px;
      padding:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      font-weight:700;
      color:var(--muted);
    }

    .muted{
      color:var(--muted);
      font-size:13px;
      margin-top:4px;
    }

    .footer{
      margin-top:auto;
      font-size:12px;
      color:rgba(255,255,255,0.45);
    }

    .legend{
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .chip{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:6px 8px;
      border-radius:999px;
      background: rgba(255,255,255,0.02);
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.03);
      font-weight:600;
      font-size:13px;
    }

    /* Accessibility focus */
    button:focus, canvas:focus{
      outline:3px solid rgba(124,246,255,0.12);
      outline-offset:4px;
    }

    /* small tip box */
    .tip{
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius:8px;
      padding:10px;
      font-size:13px;
      color:var(--muted);
      border:1px solid rgba(255,255,255,0.02);
    }

    /* multiplier HUD pulse */
    .multiplier-badge {
      display:inline-block;
      padding:8px 12px;
      border-radius:8px;
      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      color: var(--muted);
      font-weight:800;
      letter-spacing:0.6px;
      transform-origin:center;
    }
    /* Shop panel */
    .shop{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .shop-item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:6px 10px;
      border-radius:6px;
      background: rgba(255,255,255,0.03);
      font-size:13px;
      cursor:pointer;
      user-select:none;
    }
    .shop-item.disabled{
      opacity:0.35;
      pointer-events:none;
    }
    .shop-item span.level{
      font-weight:700;
      margin-left:6px;
    }
  </style>
</head>
<body>
  <div class="wrap">
      <div class="game-area" role="region" aria-label="Neon Drift game area">
          <h1>Neon Drift <span style="font-size:12px;color:var(--accent);font-weight:700;margin-left:auto">v1.1</span></h1>
          <div class="score-container">
              <div class="stat" id="scoreBox">Score: <span id="score">0</span></div>
              <div class="stat" id="livesBox">HP: <span id="hp">5</span></div>
              <div class="stat" id="waveBox">Wave: <span id="wave">0</span></div>
              <div class="stat" id="coinsBox">Coins: <span id="coins">0</span></div>
          </div>
        <canvas id="gameCanvas" tabindex="0" aria-label="Game canvas"></canvas>
    </div>

    <aside class="hud" aria-label="Game controls and stats">
      <div>
        <div style="display:flex;align-items:center;gap:8px;">
          <div style="width:48px;height:48px;border-radius:10px;background:linear-gradient(90deg,var(--neon1),var(--neon2));display:flex;align-items:center;justify-content:center;font-weight:800;color:#051021">ND</div>
          <div>
            <div style="font-weight:800">Neon Drift</div>
            <div class="muted">A tiny neon arcade. Move with WASD / arrows. Aim with mouse. Click to shoot.</div>
          </div>
        </div>
      </div>

      <div class="controls" role="group" aria-label="Game controls">
        <button id="startBtn" class="big">Start / Restart</button>
        <button id="pauseBtn">Pause</button>
        <button id="muteBtn">Toggle Sound</button>
      </div>

      <div style="display:flex;flex-direction:column;gap:8px">
        <div class="muted">Multiplier:</div>
        <div id="multiplierBadge" class="multiplier-badge">x1</div>
        <div style="height:8px;width:100%;background:rgba(255,255,255,0.02);border-radius:6px;margin-top:6px;">
          <div id="comboTimerBar" style="height:100%;width:0%;background:linear-gradient(90deg,var(--neon1),var(--neon2));border-radius:6px;"></div>
        </div>
      </div>

      <div class="tip">
        Controls:
        <ul style="margin:6px 0 0 18px;padding:0;color:var(--muted)">
          <li>Move: W A S D or Arrow keys</li>
          <li>Aim with mouse, click/hold to shoot</li>
          <li>Collect neon orbs to score and heal (score is multiplied by streak)</li>
        </ul>
      </div>

      <div>
        <div style="font-weight:800;margin-bottom:6px">Shop Upgrades (Pause to Buy)</div>
        <div id="shop" class="shop"></div>
      </div>

      <!-- <div>
        <div style="font-weight:800;margin-bottom:6px">Powerups & Tips</div>
        <div class="legend">
          <div class="chip">‚óè Enemy</div>
          <div class="chip" style="background:linear-gradient(90deg,var(--neon1),var(--neon2));color:#033;">‚óè Bullet</div>
          <div class="chip">‚óè Orb (heal/score)</div>
        </div>
      </div> -->

      <div style="margin-top:8px;">
        <div style="font-weight:800">Performance</div>
        <div id="fps" class="muted">FPS: 0</div>
      </div>

      <div class="footer">
        Built with ‚ù§Ô∏è ‚Äî tweak spawn rates, colors, or add sound effects.
      </div>
    </aside>
  </div>

  <script>
  // Neon Drift ‚Äî Compact Canvas Shooter with Powerups, Overlays, and Kill-Streak Multiplier
  (() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    // UI elements
    const scoreEl = document.getElementById('score');
    const hpEl = document.getElementById('hp');
    const waveEl = document.getElementById('wave');
    const coinsEl = document.getElementById('coins');
    const fpsEl = document.getElementById('fps');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const muteBtn = document.getElementById('muteBtn');
    const multiplierBadge = document.getElementById('multiplierBadge');
    const comboTimerBar = document.getElementById('comboTimerBar');
    const shopEl = document.getElementById('shop');

    function resizeCanvas() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(window.devicePixelRatio || 1, 1);
      canvas.width = Math.floor(rect.width * dpr);
      console.log("The value of a variable is:", canvas.width);
      canvas.height = Math.floor(rect.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Game state
    let lastTime = 0;
    let running = false;
    let paused = false;
    let muted = false;
    let bgmStarted = false;

    const state = {
      score: 0,
      hp: 5,
      wave: 0,
      shots: [],
      enemies: [],
      enemyShots: [],
      orbs: [],
      aCoins: [],
      pCoins: 0,
      particles: [],
      powerups: [], // collectible powerups
      overlays: []  // floating score overlays
    };

    const player = {
      x: 300,
      y: 300,
      vx: 0,
      vy: 0,
      speed: 220,
      baseSpeed: 220,
      radius: 12,
      fireCooldown: 0,
      fireRate: 0.12,
      angle: 0,
      numShots: 1,
      shotAngles: [0],
      damage: 1
    };

    const keys = {};
    const mouse = { x: 0, y: 0, down: false };

    const config = {
      enemySpawnBase: 1.0,
      enemySpeedBase: 50,
      orbSpawnChance: 0.06,
      maxHP: 7,
      powerupSpawnCheckInterval: 1.0,
      powerupSpawnChancePerCheck: 0.12,
      comboWindow: 1.5 // seconds between kills to keep streak
    };

    const enemyTypes = [
      { name: 'basic', hp: 1, speedMod: 1, size: 14, canShoot: false },
      { name: 'ranged', hp: 3, speedMod: 0.8, size: 16, canShoot: true, fireRate: 1.5 },
      { name: 'tank', hp: 5, speedMod: 0.6, size: 24, canShoot: false },
      { name: 'mini-boss', hp: 100, speedMod: 0.2, size: 124, canShoot: false },
      { name: 'boss', hp: 1000, speedMod: 0.1, size: 300, canShoot: false },
    ];


    // Shop upgrades
    const upgrades = [
      {name:"Fire Rate+", lvl:0, max:20, baseCost:30, effect:() => applyUpgradeEffect("Fire Rate+")},
      {name:"Damage+", lvl:0, max:20, baseCost:30, effect:() => applyUpgradeEffect("Damage+")},
      {name:"Move Speed+", lvl:0, max:20, baseCost:20, effect:() => applyUpgradeEffect("Move Speed+")},
      {name:"Max HP+", lvl:0, max:20, baseCost:25, effect:() => applyUpgradeEffect("Max HP+")},
      {name:"Heal 1 HP", lvl:0, max:20, baseCost:10, effect:() => applyUpgradeEffect("Heal 1 HP")},
      {name:"Double Shot+", lvl:0, max:20, baseCost:40, effect:() => applyUpgradeEffect("Double Shot+")}
    ];


    // === Shop rendering ===
    function renderShop(){
      shopEl.innerHTML = '';
      upgrades.forEach((u,i)=>{
        const cost = Math.floor(u.baseCost * Math.pow(1.15,u.lvl));
        const div = document.createElement('div');
        div.className = 'shop-item';
        if(u.lvl>=u.max) div.classList.add('disabled');
        div.innerHTML = `${u.name} <span class="level">${u.lvl}/${u.max}</span> ‚Äî ${u.lvl>=u.max?'MAX':cost}üíé`;
        div.onclick = () => {
          if(u.lvl<u.max && state.pCoins>=cost){
            state.pCoins = Math.max(0, state.pCoins - cost); u.lvl++; u.effect();
            renderShop();
          }
        };
        shopEl.appendChild(div);
      });
    }

    function rand(min=0, max=1){ return Math.random()*(max-min)+min; }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

    // --- AUDIO SETUP ---
    const sounds = {
      shoot: new Audio("/assets/audio/neon/shoot.wav"),
      hit: new Audio("/assets/audio/neon/explode.wav"),
      collect: new Audio("/assets/audio/neon/powerup.wav"),
      death: new Audio("/assets/audio/neon/death.wav"),
      bgm: new Audio("/assets/audio/neon/bgm.wav"),
      power_rapid: new Audio("/assets/audio/neon/powerup_rapid.wav"),
      power_shield: new Audio("/assets/audio/neon/powerup_shield.wav"),
      power_speed: new Audio("/assets/audio/neon/powerup_speed.wav"),
      power_explosion: new Audio("/assets/audio/neon/powerup_explosion.wav"),
      power_multiplier: new Audio("/assets/audio/neon/powerup_multiplier.wav"),
      combo_up: new Audio("/assets/audio/neon/powerup_multiplier.wav")
    };
    sounds.bgm.loop = true;
    sounds.bgm.volume = 0.45;

    function playSound(name){
      if(muted) return;
      const s = sounds[name];
      if(!s) return;
      try { s.currentTime = 0; s.play(); } catch(e){}
    }
    // --- END AUDIO SETUP ---

    // Powerup system
    const POWER_TYPES = ["rapidFire","shield","speed","explosion","multiplier"];
    const activePowerTimers = { rapidFire:0, shield:0, speed:0, multiplier:0 };
    let scoreMultiplier = 1;

    function spawnPowerup(x, y, type) {
      state.powerups.push({
        x: x ?? rand(60, canvas.clientWidth-60),
        y: y ?? -18,
        r: 12,
        type: type ?? POWER_TYPES[Math.floor(rand(0, POWER_TYPES.length))],
        vy: 28 + rand(-8, 8),
        age: 0
      });
    }

    function maybeSpawnPowerupByChance() {
      if (Math.random() < config.powerupSpawnChancePerCheck) spawnPowerup();
    }

    // function spawnEnemy() {
    //   const side = Math.floor(rand(0,4));
    //   let x,y;
    //   const margin = 30;
    //   if (side===0){ x = rand(0, canvas.clientWidth); y = -margin; }
    //   if (side===1){ x = rand(0, canvas.clientWidth); y = canvas.clientHeight + margin; }
    //   if (side===2){ x = -margin; y = rand(0, canvas.clientHeight); }
    //   if (side===3){ x = canvas.clientWidth + margin; y = rand(0, canvas.clientHeight); }
    //   const e = { x, y, vx:0, vy:0, speed: config.enemySpeedBase + state.wave * 6 + rand(-8,14), r: 14 + Math.floor(rand(0,2)), hp: 1 + Math.floor(rand(0,1.5)) };
    //   state.enemies.push(e);
    // }

    function getSpawnWeights(wave) {
      // Base weights
      let weights = { 'basic': 50, 'tank': 30, 'ranged': 10, 'mini-boss': 0 , 'boss': 0};

      if (wave >= 5) { // start adding ranged more
        weights['ranged'] += 20;
        weights['basic'] -= 10;
      }
      if (wave >= 10) { // add minibosses
        weights['mini-boss'] = 5 + (wave - 10) * 2; // increase over waves
        weights['basic'] = Math.max(10, weights['basic'] - 5);
        weights['tank'] = Math.max(10, weights['tank'] - 2);
        weights['ranged'] += 10;
        weights['boss'] += 20;
      }
      if (wave >= 15) { // mostly miniboss + ranged
        weights['mini-boss'] += 10;
        weights['ranged'] += 10;
        weights['basic'] = 5;
        weights['tank'] = 5;
      }

      return weights;
    }


    function pickEnemyType(wave) {
      const weights = getSpawnWeights(wave);
      const total = Object.values(weights).reduce((a,b) => a+b, 0);
      let roll = rand(0, total);
      let cumulative = 0;

      for (const type of enemyTypes) {
        cumulative += weights[type.name];
        console.log("The fart:", cumulative, "the poop", roll, "the rest", weights[type.name]);      
        if (roll < cumulative) return type;
      }

      return enemyTypes[0]; // fallback
    }

    function spawnEnemy() {
      const side = Math.floor(rand(0, 4));
      let x, y;
      const margin = 30;

      if (side === 0) { x = rand(0, canvas.clientWidth); y = -margin; }
      if (side === 1) { x = rand(0, canvas.clientWidth); y = canvas.clientHeight + margin; }
      if (side === 2) { x = -margin; y = rand(0, canvas.clientHeight); }
      if (side === 3) { x = canvas.clientWidth + margin; y = rand(0, canvas.clientHeight); }

      const type = pickEnemyType(state.wave);

      const e = {
        x, y, vx: 0, vy: 0,
        speed: (config.enemySpeedBase + state.wave * 6 + rand(-8, 14)) * type.speedMod,
        r: type.size,
        hp: type.hp,
        maxHP: type.hp,
        type: type.name,
        canShoot: type.canShoot || false,
        fireCooldown: 0,
        fireRate: type.fireRate || 0
      };

      state.enemies.push(e);
    }



    function spawnOrb(x,y){
      state.orbs.push({ x,y, r:8, kind: Math.random() < 0.25 ? 'heal' : 'score', age:0 });
    }

    function spawnCoin(x = null, y = null) {
      state.aCoins.push({
        x: x ?? rand(30, canvas.clientWidth-30),
        y: y ?? rand(30, canvas.clientHeight-30),
        r: 8,
        age: 0,
        value: 5 // base coin value
      });
    }

    function enemyKilled(e, baseValue = 5) {
      // Determine number of coins based on enemy type or size
      let numCoins = 1;
      let coinValue = baseValue;

      switch(e.type) {
        case 'tank':
          numCoins = 5;//+ Math.floor(e.hpMax/2); // tanks drop more
          coinValue = 5;
          break;
        case 'ranged':
          numCoins = 2;
          coinValue = 5;
          break;
        case 'mini-boss':
          numCoins = 20;// + Math.floor(e.hpMax/2);
          coinValue = 5;
          break;
        case 'boss':
          numCoins = 100;// + Math.floor(e.hpMax/2);
          coinValue = 5;
          break;
        default: // normal enemy
          numCoins = 1;// + Math.floor(e.hpMax/2);
          coinValue = 5;
      }

      // spawnCoin(e.x, e.y);
      // Spawn coins in a small circle around the enemy
      for (let i = 0; i < numCoins; i++) {
        console.log("The fart:", i);
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * e.r * 0.1; // spread around enemy
        const coinX = e.x + Math.cos(angle) * radius;
        const coinY = e.y + Math.sin(angle) * radius;
        state.aCoins.push({
          x: coinX,
          y: coinY,
          r: 8,
          age: 0,
          value: coinValue
        });
        // spawnCoin(coinX, coinY);
      }
    }


    window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' '){ e.preventDefault(); } });
    window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mousedown', e => { mouse.down = true; canvas.focus(); });
    window.addEventListener('mouseup', e => mouse.down = false);

    canvas.addEventListener('touchstart', e => {
      e.preventDefault();
      const t = e.touches[0]; const rect = canvas.getBoundingClientRect();
      mouse.x = t.clientX - rect.left; mouse.y = t.clientY - rect.top; mouse.down = true; canvas.focus();
    }, { passive:false });
    canvas.addEventListener('touchmove', e => { e.preventDefault(); const t = e.touches[0]; const rect = canvas.getBoundingClientRect(); mouse.x = t.clientX - rect.left; mouse.y = t.clientY - rect.top; }, { passive:false });
    window.addEventListener('touchend', e => { mouse.down = false; });

    startBtn.addEventListener('click', () => startGame());
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if (!paused && running) { lastTime = performance.now(); requestAnimationFrame(loop); }
    });
    muteBtn.addEventListener('click', () => { muted = !muted; muteBtn.textContent = muted ? 'Unmute' : 'Toggle Sound'; if(muted){ try { sounds.bgm.pause(); } catch{} } else { if(bgmStarted) playSound('bgm'); } });

    function resetState() {
      state.score = 0; state.hp = 5; state.wave = 0; state.shots = []; state.enemies = []; state.enemyShots = []; state.orbs = []; state.aCoins = []; state.pCoins = 0; state.particles = []; state.powerups = []; state.overlays = [];
      player.x = canvas.clientWidth/2; player.y = canvas.clientHeight/2; player.vx = 0; player.vy = 0; player.fireCooldown = 0; player.angle = 0;
      activePowerTimers.rapidFire = activePowerTimers.shield = activePowerTimers.speed = activePowerTimers.multiplier = 0;
      scoreMultiplier = 1;
      player.speed = player.baseSpeed;
      consecutiveKills = 0;
      comboTimer = 0;
      multiplierPulse = 0;
    }

    function startGame(){
      resetState(); running = true; paused = false; lastTime = performance.now();
      waveTimer = 0; spawnTimer = 0; powerupSpawnTimer = 0;
      pauseBtn.textContent = 'Pause';
      if(!muted && !bgmStarted){ playSound('bgm'); bgmStarted = true; }
      renderShop();
      requestAnimationFrame(loop);
    }

    function spawnParticles(x,y,color,count=8){ for(let i=0;i<count;i++){ state.particles.push({ x,y, vx: rand(-120,120), vy: rand(-120,120), life: rand(0.4,0.9), age:0, color }); } }

    // overlays: floating score texts
    // { x, y, text, color, age, life, scale }
    function spawnOverlay(x,y,text,color='#7cf6ff',life=0.9){
      state.overlays.push({ x, y, text, color, age:0, life, scale:0.6 });
    }

    // Combo / multiplier
    let consecutiveKills = 0;
    let comboTimer = 0; // counts down
    let multiplierPulse = 0; // animation value when multiplier bumps

    function bumpComboOnKill() {
      // if combo still active, increment; else start at 1 (first kill)
      if(comboTimer > 0) {
        consecutiveKills = Math.max(1, consecutiveKills) + 1;
      } else {
        consecutiveKills = 1;
      }
      comboTimer = config.comboWindow;
      scoreMultiplier = consecutiveKills; // multiplier equals number of consecutive kills
      multiplierPulse = 1.0; // trigger animation
      playSound('combo_up');
    }

    function applyUpgradeEffect(upgradeName) {
      switch(upgradeName) {
        case "Fire Rate+":
          player.fireRate *= 0.92;
          break;
        case "Damage+":
          player.damage += 1;
          break;
        case "Move Speed+":
          player.baseSpeed *= 1.05;
          player.speed = player.baseSpeed;
          break;
        case "Max HP+":
          config.maxHP += 1;
          state.hp += 1;
          break;
        case "Heal 1 HP":
          state.hp = Math.min(config.maxHP, state.hp + 1);
          break;
        case "Double Shot+":
          // Increase number of shots and distribute angles evenly
          if (!player.numShots) player.numShots = 1;
          player.numShots++;
          player.shotAngles = [];
          for (let i = 0; i < player.numShots; i++) {
            player.shotAngles.push((360 / player.numShots) * i); // degrees
          }
          break;
        default:
          console.warn("Unknown upgrade:", upgradeName);
      }
    }

    function handlePowerupPickup(type){
      switch(type){
        case 'rapidFire':
          activePowerTimers.rapidFire = 10.0; playSound('power_rapid'); break;
        case 'shield':
          activePowerTimers.shield = 8.0; playSound('power_shield'); break;
        case 'speed':
          activePowerTimers.speed = 8.0; player.speed = player.baseSpeed * 1.6; playSound('power_speed'); break;
        case 'explosion':
          let destroyed = 0;
          for(let i=state.enemies.length-1;i>=0;i--){
            const e = state.enemies[i];
            spawnParticles(e.x, e.y, '#ff7dd1', 12);
            // spawnCoin(e.x, e.y);
            enemyKilled(e);
            const baseScore = 10 + Math.floor(state.wave*2);
            state.score += Math.round(baseScore * scoreMultiplier);
            state.enemies.splice(i,1);
            destroyed++;
          }
          playSound('power_explosion');
          spawnParticles(player.x, player.y, '#ff7dd1', Math.min(60, destroyed * 4));
          break;
        case 'multiplier':
          activePowerTimers.multiplier = 12.0;
          scoreMultiplier = Math.max(1, scoreMultiplier) * 2; // double current multiplier
          multiplierPulse = 1.0;
          playSound('power_multiplier');
          break;
        default:
          playSound('collect');
      }
    }

    // function fireBullet() {
    //   if(player.fireCooldown>0) return;
    //   const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    //   const speed = 420;
    //   state.shots.push({ x: player.x + Math.cos(angle)*(player.radius+6), y: player.y + Math.sin(angle)*(player.radius+6), vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed, r:4, life:1.6 });
    //   const rapidActive = activePowerTimers.rapidFire > 0;
    //   player.fireCooldown = player.fireRate * (rapidActive ? 0.5 : 1);
    //   spawnParticles(player.x + Math.cos(angle)*(player.radius+6), player.y + Math.sin(angle)*(player.radius+6), '#7cf6ff', 6);
    //   playSound('shoot');
    // }
    function fireBullet() {
      if (player.fireCooldown > 0) return;

      const speed = 420;
      const rapidActive = activePowerTimers.rapidFire > 0;
      player.fireCooldown = player.fireRate * (rapidActive ? 0.5 : 1);

      // Calculate base angle toward mouse
      const baseAngle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

      // Distribute shots evenly around the base angle
      for (let i = 0; i < player.numShots; i++) {
        // Spread shots evenly in a circle
        const angleOffset = (i / player.numShots) * 2 * Math.PI; // Full circle
        const angle = baseAngle + angleOffset;

        // Spawn bullet
        const bx = player.x + Math.cos(angle) * (player.radius + 6);
        const by = player.y + Math.sin(angle) * (player.radius + 6);

        state.shots.push({
          x: bx,
          y: by,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          r: 4,
          life: 1.6
        });

        // Particle effect
        spawnParticles(bx, by, '#7cf6ff', 6);
      }

      playSound('shoot');
    }

    function fireEnemyBullet(enemy) {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const speed = 180;
      state.enemyShots.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        r: 5,
        life: 3
      });
    }


    let waveTimer = 0, spawnTimer = 0, powerupSpawnTimer = 0;

    function update(dt){
      if(!running || paused) return;

      // active power timers
      if(activePowerTimers.rapidFire > 0) activePowerTimers.rapidFire = Math.max(0, activePowerTimers.rapidFire - dt);
      if(activePowerTimers.shield > 0) activePowerTimers.shield = Math.max(0, activePowerTimers.shield - dt);
      if(activePowerTimers.speed > 0) activePowerTimers.speed = Math.max(0, activePowerTimers.speed - dt);
      if(activePowerTimers.multiplier > 0) {
        activePowerTimers.multiplier = Math.max(0, activePowerTimers.multiplier - dt);
        if(activePowerTimers.multiplier === 0){
          // multiplier power ended; if no consecutive kills, reset to 1
          if(consecutiveKills <= 1) scoreMultiplier = 1;
        }
      }

      // combo timer decay
      if(comboTimer > 0) {
        comboTimer = Math.max(0, comboTimer - dt);
        if(comboTimer === 0){
          // reset multipliers when timer expires
          consecutiveKills = 0;
          scoreMultiplier = 1;
        }
      }

      // multiplier pulse animation decay
      if(multiplierPulse > 0) multiplierPulse = Math.max(0, multiplierPulse - dt * 2.8);

      player.fireCooldown = Math.max(0, player.fireCooldown - dt);
      waveTimer += dt; spawnTimer += dt; powerupSpawnTimer += dt;

      // Movement input
      let ax=0, ay=0;
      if(keys['w'] || keys['arrowup']) ay -= 1;
      if(keys['s'] || keys['arrowdown']) ay += 1;
      if(keys['a'] || keys['arrowleft']) ax -= 1;
      if(keys['d'] || keys['arrowright']) ax += 1;
      const m = Math.hypot(ax,ay) || 1;
      player.vx = (player.vx*0.85) + (ax/m)*player.speed*0.15;
      player.vy = (player.vy*0.85) + (ay/m)*player.speed*0.15;
      player.x += player.vx * dt; player.y += player.vy * dt;

      player.x = clamp(player.x, 12, canvas.clientWidth-12);
      player.y = clamp(player.y, 12, canvas.clientHeight-12);

      player.angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);

      if (mouse.down) fireBullet();

      // Shots update
      for (let i = state.shots.length-1; i>=0; i--){
        const s = state.shots[i];
        s.x += s.vx * dt; s.y += s.vy * dt; s.life -= dt;
        if (s.life <= 0 || s.x < -50 || s.y < -50 || s.x > canvas.clientWidth+50 || s.y > canvas.clientHeight+50){
          state.shots.splice(i,1);
        }
      }

      // Enemy shots update
      for (let i = state.enemyShots.length-1; i>=0; i--){
        const s = state.enemyShots[i];
        s.x += s.vx * dt; s.y += s.vy * dt; s.life -= dt;
        if (s.life <= 0 || s.x < -50 || s.y < -50 || s.x > canvas.clientWidth+50 || s.y > canvas.clientHeight+50){
          state.enemyShots.splice(i,1);
        }
      }

      // Waves: every 12 seconds new wave
      if (waveTimer > 12) {
        state.wave++; waveTimer = 0;
        spawnOrb(rand(60, canvas.clientWidth-60), rand(60, canvas.clientHeight-60));
      }

      // Spawn enemies
      const spawnRate = Math.max(0.25, config.enemySpawnBase + state.wave * 0.25);
      if (spawnTimer > 1/spawnRate) { spawnTimer = 0; spawnEnemy(); }

      // Chance-based powerup spawn check
      if (powerupSpawnTimer >= config.powerupSpawnCheckInterval) {
        powerupSpawnTimer = 0;
        if (Math.random() < config.powerupSpawnChancePerCheck) spawnPowerup();
      }

      // Enemies
      for (let i = state.enemies.length-1; i>=0; i--){
        const e = state.enemies[i];
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const distance = Math.hypot(dx, dy);
        const angleToPlayer = Math.atan2(dy, dx);

        // ---- Movement ----
        if (e.type === 'ranged') {
          // Maintain distance from player
          const desiredDistance = 180; // pixels
          if (distance < desiredDistance) {
            // Move away from player
            e.vx -= Math.cos(angleToPlayer) * e.speed * dt * 0.5;
            e.vy -= Math.sin(angleToPlayer) * e.speed * dt * 0.5;
          } else if (distance > desiredDistance + 40) {
            // Move closer if too far
            e.vx += Math.cos(angleToPlayer) * e.speed * dt * 0.5;
            e.vy += Math.sin(angleToPlayer) * e.speed * dt * 0.5;
          }
        } else {
          // Basic or tank: move directly toward player
          e.vx += Math.cos(angleToPlayer) * 20 * dt;
          e.vy += Math.sin(angleToPlayer) * 20 * dt;
        }

        // Clamp speed
        const speed = Math.hypot(e.vx, e.vy) || 1;
        e.vx = (e.vx / speed) * Math.min(speed, e.speed);
        e.vy = (e.vy / speed) * Math.min(speed, e.speed);

        // Update position
        e.x += e.vx * dt;
        e.y += e.vy * dt;

        // ---- Shooting for ranged enemies ----
        if (e.canShoot) {
          e.fireCooldown = (e.fireCooldown || 0) - dt;
          if (e.fireCooldown <= 0) {
            fireEnemyBullet(e, angleToPlayer);
            e.fireCooldown = e.fireRate;
          }
        }

        // ---- Collision with player (same as before) ----
        const dxp = e.x - player.x, dyp = e.y - player.y;
        const rr = e.r + player.radius;
        if (dxp*dxp + dyp*dyp < rr*rr) {
          if (activePowerTimers.shield > 0) {
            spawnParticles(e.x, e.y, '#ffb3e0', 12);
            state.enemies.splice(i, 1);
            playSound('hit');
            continue;
          }
          state.hp--;
          spawnParticles(player.x, player.y, '#ff7dd1', 12);
          player.vx -= Math.cos(angleToPlayer) * 120;
          player.vy -= Math.sin(angleToPlayer) * 120;
          state.enemies.splice(i, 1);
          playSound('hit');
          if (state.hp <= 0) { playSound('death'); gameOver(); return; }
          continue;
        }

        // bullets hitting enemy
        let hit = false;
        for (let j = state.shots.length-1; j>=0; j--){
          const b = state.shots[j];
          const dx2 = b.x - e.x, dy2 = b.y - e.y;
          if (dx2*dx2 + dy2*dy2 < (b.r + e.r)*(b.r + e.r)) {
            e.hp-=player.damage;
            state.shots.splice(j,1);
            spawnParticles(e.x, e.y, '#7cf6ff', 6);
            playSound('hit');
            if (e.hp <= 0) {
              // enemy died: bump combo, award multiplied score, overlay, possible powerup drop
              bumpComboOnKill();
              const baseScore = 10 + Math.floor(state.wave*2);
              const awarded = Math.round(baseScore * scoreMultiplier);
              state.score += awarded;
              spawnOverlay(e.x, e.y, '+' + awarded, computeMultiplierColor(scoreMultiplier), 0.95);
              spawnParticles(e.x, e.y, '#7d7bff', 18);
              // small chance for orb or powerup
              if (Math.random() < 0.15) spawnOrb(e.x, e.y);
              if (Math.random() < 0.06) spawnPowerup(e.x, e.y);
              // spawnCoin(e.x, e.y);
              enemyKilled(e);
              state.enemies.splice(i,1);
            } else {
              // hit but not killed: small score
              const small = Math.round(3 * scoreMultiplier);
              state.score += small;
              spawnOverlay(b.x, b.y, '+' + small, '#7cf6ff', 0.7);
            }
            hit = true;
            break;
          }
        }
        if (hit) continue;
      }

      // enemy shot collision with player
      for (let j = state.enemyShots.length - 1; j >= 0; j--) {
        const b = state.enemyShots[j];
        const dx = b.x - player.x;
        const dy = b.y - player.y;
        const rr = b.r + player.radius;
        
        if (dx*dx + dy*dy < rr*rr) {
          if (activePowerTimers.shield > 0) {
            state.enemyShots.splice(j, 1); // remove the bullet
            spawnParticles(player.x, player.y, '#ff7dd1', 12); // player hit effect
            playSound('hit');
            continue;
          }
          // Hit detected
          state.hp--; // reduce player HP
          spawnParticles(player.x, player.y, '#ff7dd1', 12);
          state.enemyShots.splice(j, 1);
          playSound('hit');
          
          if (state.hp <= 0) {
            playSound('death');
            gameOver();
            return;
          }
          continue;
        }
      }

      // Orbs
      for (let i = state.orbs.length-1; i>=0; i--){
        const o = state.orbs[i];
        o.age += dt;
        o.y += Math.sin(o.age*2.2) * 0.2;
        const d2 = (o.x-player.x)*(o.x-player.x)+(o.y-player.y)*(o.y-player.y);
        if (d2 < (o.r + player.radius + 6)*(o.r + player.radius + 6)) {
          if (o.kind === 'heal') {
            state.hp = Math.min(config.maxHP, state.hp + 1);
            // heal overlay
            spawnOverlay(o.x, o.y, '+HP', '#7ef0a3', 0.9);
          } else {
            // score orb is now multiplied
            const orbBase = 15 + Math.floor(state.wave*3);
            const orbAward = Math.round(orbBase * scoreMultiplier);
            state.score += orbAward;
            spawnOverlay(o.x, o.y, '+' + orbAward, computeMultiplierColor(scoreMultiplier), 0.95);
          }
          spawnParticles(o.x, o.y, '#7cf6ff', 12);
          playSound('collect');
          state.orbs.splice(i,1);
        } else if (o.age > 12) {
          state.orbs.splice(i,1);
        }
      }
      // Collect coins
      for (let i = state.aCoins.length - 1; i >= 0; i--) {
        const c = state.aCoins[i];
        c.age += dt;
        const d2 = (c.x - player.x)*(c.x - player.x) + (c.y - player.y)*(c.y - player.y);
        if (d2 < (c.r + player.radius + 6)*(c.r + player.radius + 6)) {
          state.pCoins += c.value; // coins add to coins count
          spawnOverlay(c.x, c.y, `+${c.value}üíé`, '#ffd166', 0.8);
          spawnParticles(c.x, c.y, '#ffd166', 8);
          playSound('collect');
          state.aCoins.splice(i, 1);
        } //else if (c.age > 12) state.aCoins.splice(i,1);
      }

      // Powerups on field
      for (let i = state.powerups.length-1; i>=0; i--){
        const p = state.powerups[i];
        p.age += dt;
        p.y += p.vy * dt;
        p.x += Math.sin(p.age*2.3) * 0.3;
        if (p.y > canvas.clientHeight + 40) { state.powerups.splice(i,1); continue; }
        const dd = (p.x - player.x)*(p.x - player.x) + (p.y - player.y)*(p.y - player.y);
        if (dd < (p.r + player.radius + 6)*(p.r + player.radius + 6)) {
          // pickup
          handlePowerupPickup(p.type);
          // visual & sound already played in handler
          state.powerups.splice(i,1);
        }
      }

      // overlays update (floating score text)
      for (let i = state.overlays.length-1; i>=0; i--){
        const o = state.overlays[i];
        o.age += dt;
        o.y -= 14 * dt; // float upward
        o.scale += (1.4 - o.scale) * (dt * 6); // ease up
        if (o.age >= o.life) state.overlays.splice(i,1);
      }

      // particles
      for (let i = state.particles.length-1; i>=0; i--){
        const p = state.particles[i];
        p.age += dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.98; p.vy *= 0.98;
        if (p.age >= p.life) state.particles.splice(i,1);
      }

      // update UI values & HUD animations
      // Score text includes multiplier if >1
      const multiText = scoreMultiplier > 1 ? ` (x${scoreMultiplier})` : '';
      scoreEl.textContent = String(state.score) + multiText;
      hpEl.textContent = String(state.hp);
      waveEl.textContent = String(state.wave);
      coinsEl.textContent = String(state.pCoins);

      // multiplier badge animation
      multiplierBadge.textContent = 'x' + scoreMultiplier;
      if(multiplierPulse > 0){
        const s = 1 + Math.min(1.25, multiplierPulse * 0.6);
        multiplierBadge.style.transform = `scale(${s})`;
        multiplierBadge.style.color = (scoreMultiplier >= 4) ? '#ff7dd1' : (scoreMultiplier >= 2 ? '#f6a9ff' : '#7cf6ff');
      } else {
        multiplierBadge.style.transform = 'scale(1)';
        multiplierBadge.style.color = '#7cf6ff';
      }

      // combo timer bar fill
      const fill = clamp((comboTimer / config.comboWindow) * 100, 0, 100);
      comboTimerBar.style.width = `${fill}%`;
    }

    // helper to compute overlay color by multiplier
    function computeMultiplierColor(mult){
      if(mult <= 1) return '#7cf6ff';
      if(mult === 2) return '#7ef0a3';
      if(mult === 3) return '#ffd166';
      if(mult === 4) return '#ff7dd1';
      return '#f6a9ff';
    }

    function draw() {
      // clear
      ctx.fillStyle = '#07070b';
      ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight);

      // subtle grid lines / starfield
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.save();
      const gx = ctx.createRadialGradient(w/2,h/2,30,w/2,h/2,Math.max(w,h));
      gx.addColorStop(0,'rgba(125,123,255,0.04)');
      gx.addColorStop(1,'rgba(0,0,0,0)');
      ctx.fillStyle = gx;
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      // draw powerups
      for (const p of state.powerups){
        ctx.save();
        let color = '#ffd166';
        if(p.type === 'rapidFire') color = '#ffd166';
        if(p.type === 'shield') color = '#7ef0a3';
        if(p.type === 'speed') color = '#7cf6ff';
        if(p.type === 'explosion') color = '#ff7dd1';
        if(p.type === 'multiplier') color = '#f6a9ff';

        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.12;
        ctx.arc(p.x, p.y, p.r+10, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = '#051021';
        ctx.font = '700 10px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        let letter = '?';
        if(p.type==='rapidFire') letter = 'RF';
        if(p.type==='shield') letter = 'SH';
        if(p.type==='speed') letter = 'SP';
        if(p.type==='explosion') letter = 'EX';
        if(p.type==='multiplier') letter = 'x2';
        ctx.fillText(letter, p.x, p.y);
        ctx.restore();
      }

      // draw orbs
      for (const o of state.orbs){
        ctx.save();
        ctx.beginPath();
        const g = ctx.createLinearGradient(o.x-8,o.y-8,o.x+8,o.y+8);
        g.addColorStop(0,'#7cf6ff');
        g.addColorStop(1,'#7d7bff');
        ctx.fillStyle = g;
        ctx.shadowColor = 'rgba(49, 96, 100, 1)';
        ctx.shadowBlur = 26;
        ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // draw coins
      for (const o of state.aCoins) {
        ctx.save();
        ctx.beginPath();

        // Golden gradient
        const g = ctx.createRadialGradient(o.x, o.y, o.r * 0.2, o.x, o.y, o.r);
        g.addColorStop(0, '#FFF9A6');   // bright inner highlight
        g.addColorStop(0.5, '#FFD700'); // gold
        g.addColorStop(1, '#B8860B');   // darker gold edge

        ctx.fillStyle = g;

        // Strong yellow glow
        ctx.shadowColor = 'rgba(255, 215, 0, 0.9)'; // golden glow (much more visible)
        ctx.shadowBlur = o.r * 2.5;                 // scale with coin size

        // Draw coin
        ctx.arc(o.x, o.y, o.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }


      // draw shots
      for (const s of state.shots){
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = '#7cf6ff';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#7cf6ff';
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // draw enemy shots
      for (const s of state.enemyShots){
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = '#ff0000';
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#7cf6ff';
        ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // draw enemies
      for (const e of state.enemies){
        ctx.save();
        ctx.translate(e.x,e.y);
        ctx.rotate(Math.atan2(player.y - e.y, player.x - e.x));
        ctx.beginPath();
        ctx.fillStyle = '#ff7dd1';
        ctx.shadowBlur = 14;
        ctx.shadowColor = '#ff7dd1';
        ctx.moveTo(-e.r, -e.r*0.6);
        ctx.lineTo(e.r, 0);
        ctx.lineTo(-e.r, e.r*0.6);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.fillStyle = '#ffb3e0';
        ctx.arc(-e.r*0.2, 0, e.r*0.42, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // draw overlays (floating score)
      for (const ov of state.overlays){
        ctx.save();
        const t = ov.age / ov.life;
        const alpha = clamp(1 - t, 0, 1);
        const scale = ov.scale * (1 + t*0.5);
        ctx.globalAlpha = alpha;
        ctx.font = `${Math.round(14 * scale)}px Inter, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // glow text
        ctx.shadowColor = ov.color;
        ctx.shadowBlur = 18 * (1 - t);
        ctx.fillStyle = ov.color;
        ctx.fillText(ov.text, ov.x, ov.y - (t * 18));
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 0;
        ctx.restore();
      }

      // draw player
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.angle);

      // shield visual
      if(activePowerTimers.shield > 0){
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(126, 240, 163, 0.65)';
        ctx.lineWidth = 4;
        ctx.arc(0,0,player.radius+10,0,Math.PI*2);
        ctx.stroke();
      }

      // speed trail
      if(activePowerTimers.speed > 0){
        ctx.beginPath();
        ctx.fillStyle = 'rgba(124,246,255,0.06)';
        ctx.arc(-player.vx*0.02, -player.vy*0.02, player.radius+8, 0, Math.PI*2);
        ctx.fill();
      }

      // glow and ship
      ctx.beginPath();
      ctx.fillStyle = 'rgba(124,246,255,0.06)';
      ctx.shadowColor = '#7cf6ff';
      ctx.shadowBlur = 28;
      ctx.arc(0,0,player.radius+8,0,Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = '#071021';
      ctx.moveTo(player.radius+6, 0);
      ctx.lineTo(-player.radius, -player.radius*0.7);
      ctx.lineTo(-player.radius, player.radius*0.7);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#7cf6ff';
      ctx.moveTo(player.radius+6, 0);
      ctx.lineTo(-player.radius, -player.radius*0.7);
      ctx.lineTo(-player.radius, player.radius*0.7);
      ctx.closePath();
      ctx.stroke();
      ctx.restore();

      // draw particles
      for (const p of state.particles){
        const t = 1 - (p.age / p.life);
        ctx.beginPath();
        ctx.globalAlpha = clamp(t,0,1);
        ctx.fillStyle = p.color;
        ctx.arc(p.x, p.y, 2.6 + (t*2), 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      // HUD overlays (center)
      ctx.save();
      ctx.beginPath();
      ctx.strokeStyle = 'rgba(124,246,255,0.18)';
      ctx.lineWidth = 1.2;
      ctx.arc(mouse.x, mouse.y, 10, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function gameOver(){
      running = false;
      paused = false;
      spawnParticles(player.x, player.y, '#ff7dd1', 48);
      setTimeout(()=> {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0,0, canvas.clientWidth, canvas.clientHeight);
        ctx.fillStyle = '#fff';
        ctx.font = '600 28px Inter, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.clientWidth/2, canvas.clientHeight/2 - 18);
        ctx.font = '500 16px Inter, sans-serif';
        ctx.fillText('Score: ' + state.score, canvas.clientWidth/2, canvas.clientHeight/2 + 12);
        ctx.restore();
      }, 120);
    }

    let frames = 0, fpsTimer = 0;
    function loop(ts) {
      if (!running || paused) return;
      const dt = Math.min(0.05, (ts - lastTime) / 1000 || 0.016);
      lastTime = ts;
      update(dt);
      draw();
      frames++;
      fpsTimer += dt;
      if (fpsTimer > 0.5) {
        fpsEl.textContent = 'FPS: ' + Math.round(frames / fpsTimer);
        frames = 0; fpsTimer = 0;
      }
      requestAnimationFrame(loop);
    }

    // init
    function initPosition() { player.x = canvas.clientWidth/2; player.y = canvas.clientHeight/2; }
    initPosition();

    canvas.addEventListener('click', () => canvas.focus());
    canvas.setAttribute('role','application');
    setTimeout(resizeCanvas, 50);
  })();
  </script>
</body>
</html>
